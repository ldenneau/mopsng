# This file was automatically generated by SWIG
package PS::MOPS::DB::Observation;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package PS::MOPS::DB::Observationc;
bootstrap PS::MOPS::DB::Observation;
package PS::MOPS::DB::Observation;

%EXPORT_TAGS = ( 'all' => [ qw(
    modcm_toStruct
    modcm_toStructArray
    modcm_getCount
    modcm_getDetectionCount
    modcm_getDetections
    modcm_create
    modcm_retrieve
    modcm_retrieveByValue
    modcm_insert
    modcm_insertByValue
    modcm_addDetections
    modcm_delete
    modcm_free
    modcm_freeArray
    modcm_freeStruct
    modcm_freeArrayStruct
    modcm_getId
    modcm_getRa
    modcm_getDec
    modcm_getEpoch
    modcm_getSurveyMode
    modcm_getTimeStop
    modcm_getTimeStart
    modcm_getFilter
    modcm_getLimitingMag
    modcm_getRaSigma
    modcm_getDecSigma
    modcm_getObservatory
    modcm_getEfficiencies
    modcm_next
    modcm_prev
    modcm_nextDetection
    modcm_prevDetection
) ] );
                                                                                                               
@EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

@EXPORT = qw( );

# ---------- BASE METHODS -------------

package PS::MOPS::DB::Observation;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package PS::MOPS::DB::Observation;

*new_doubleArray = *PS::MOPS::DB::Observationc::new_doubleArray;
*doubleArray_setitem = *PS::MOPS::DB::Observationc::doubleArray_setitem;
*doubleArray_getitem = *PS::MOPS::DB::Observationc::doubleArray_getitem;
*delete_doubleArray = *PS::MOPS::DB::Observationc::delete_doubleArray;
*modcm_toStruct = *PS::MOPS::DB::Observationc::modcm_toStruct;
*modcm_toStructArray = *PS::MOPS::DB::Observationc::modcm_toStructArray;
*modcm_getCount = *PS::MOPS::DB::Observationc::modcm_getCount;
*modcm_getDetectionCount = *PS::MOPS::DB::Observationc::modcm_getDetectionCount;
*modcm_getDetections = *PS::MOPS::DB::Observationc::modcm_getDetections;
#*modcm_create = *PS::MOPS::DB::Observationc::modcm_create;
*modcm_retrieve = *PS::MOPS::DB::Observationc::modcm_retrieve;
*modcm_retrieveByValue = *PS::MOPS::DB::Observationc::modcm_retrieveByValue;
*modcm_insert = *PS::MOPS::DB::Observationc::modcm_insert;
#*modcm_insertByValue = *PS::MOPS::DB::Observationc::modcm_insertByValue;
*modcm_addDetections = *PS::MOPS::DB::Observationc::modcm_addDetections;
*modcm_delete = *PS::MOPS::DB::Observationc::modcm_delete;
*modcm_free = *PS::MOPS::DB::Observationc::modcm_free;
*modcm_freeArray = *PS::MOPS::DB::Observationc::modcm_freeArray;
*modcm_freeStruct = *PS::MOPS::DB::Observationc::modcm_freeStruct;
*modcm_freeArrayStruct = *PS::MOPS::DB::Observationc::modcm_freeArrayStruct;
*modcm_getId = *PS::MOPS::DB::Observationc::modcm_getId;
*modcm_getRa = *PS::MOPS::DB::Observationc::modcm_getRa;
*modcm_getDec = *PS::MOPS::DB::Observationc::modcm_getDec;
*modcm_getEpoch = *PS::MOPS::DB::Observationc::modcm_getEpoch;
*modcm_getSurveyMode = *PS::MOPS::DB::Observationc::modcm_getSurveyMode;
*modcm_getTimeStop = *PS::MOPS::DB::Observationc::modcm_getTimeStop;
*modcm_getTimeStart = *PS::MOPS::DB::Observationc::modcm_getTimeStart;
*modcm_getFilter = *PS::MOPS::DB::Observationc::modcm_getFilter;
*modcm_getLimitingMag = *PS::MOPS::DB::Observationc::modcm_getLimitingMag;
*modcm_getRaSigma = *PS::MOPS::DB::Observationc::modcm_getRaSigma;
*modcm_getDecSigma = *PS::MOPS::DB::Observationc::modcm_getDecSigma;
*modcm_getObservatory = *PS::MOPS::DB::Observationc::modcm_getObservatory;
*modcm_getEfficiencies = *PS::MOPS::DB::Observationc::modcm_getEfficiencies;
*modcm_next = *PS::MOPS::DB::Observationc::modcm_next;
*modcm_prev = *PS::MOPS::DB::Observationc::modcm_prev;
*modcm_nextDetection = *PS::MOPS::DB::Observationc::modcm_nextDetection;
*modcm_prevDetection = *PS::MOPS::DB::Observationc::modcm_prevDetection;

sub modcm_create {
    # Create an Observation object without inserting into PSMOPS;
    # return the opaque object as a scalar.
    die "wrong number of arguments" unless @_ == 12;

    # alloc ptr for doubles
    my $DoubleArray = new_doubleArray(10);
    my $d;

    # Last item in input array is ref to array of doubles.  Stuff em in ptr array.
    my $n = 0;
    foreach $d (@{$_[-1]}) {
        doubleArray_setitem($DoubleArray, $n, $d);
        $n++;
    }
    my $obj = PS::MOPS::DB::Observationc::modcm_create(@_[0..10], $DoubleArray);
    delete_doubleArray($DoubleArray);
    return $obj;
}

sub modcm_insertByValue {
    # Create and insert a new Observation object; return the opaque object.
    die "wrong number of arguments" unless @_ == 12;

    # alloc ptr for doubles
    my $DoubleArray = new_doubleArray(10);
    my $d;

    # Last item in input array is ref to array of doubles.  Stuff em in ptr array.
    my $n = 0;
    foreach $d (@{$_[-1]}) {
        doubleArray_setitem($DoubleArray, $n, $d);
        $n++;
    }
    my $obj = PS::MOPS::DB::Observationc::modcm_insertByValue(@_[0..10], $DoubleArray);
    delete_doubleArray($DoubleArray);
    return $obj;
}

# ------- VARIABLE STUBS --------

package PS::MOPS::DB::Observation;

1;
